<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../lambda2.ico">
        

	<title>Whole API - Laplacians.jl</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../Laplacians.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

            <!-- Main title -->
            <a class="navbar-brand" href="../about/index.html">Laplacians.jl</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            <!-- Main navigation -->
            <ul class="nav navbar-nav">
            
            
                <li >
                    <a href="../about/index.html">About</a>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">User Guide <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../Julia/index.html">Using Julia</a>
                        </li>
                    
                        <li >
                            <a href="../Laplacians/index.html">Introduction</a>
                        </li>
                    
                        <li >
                            <a href="../solvers/index.html">Solvers</a>
                        </li>
                    
                        <li >
                            <a href="../Examples/index.html">Examples</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Developing <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li >
                            <a href="../Developing/index.html">Devleoping Laplacians</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            
                <li class="dropdown active">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown">API <b class="caret"></b></a>
                    <ul class="dropdown-menu">
                    
                        <li class="active">
                            <a href="index.html">Whole API</a>
                        </li>
                    
                        <li >
                            <a href="../graphGeneratorsAPI/index.html">graphGenerators</a>
                        </li>
                    
                        <li >
                            <a href="../IOAPI/index.html">IO</a>
                        </li>
                    
                        <li >
                            <a href="../graphOpsAPI/index.html">graphOps</a>
                        </li>
                    
                        <li >
                            <a href="../graphAlgsAPI/index.html">graphAlgs</a>
                        </li>
                    
                        <li >
                            <a href="../cutPageRankAPI/index.html">cutPageRank</a>
                        </li>
                    
                        <li >
                            <a href="../solversAPI/index.html">solvers</a>
                        </li>
                    
                    </ul>
                </li>
            
            
            </ul>

            <!-- Search, Navigation and Repo links -->
            <ul class="nav navbar-nav navbar-right">
                <li >
                    <a rel="next" href="../Developing/index.html">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </li>
                <li >
                    <a rel="prev" href="../graphGeneratorsAPI/index.html">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </li>
                
                <li>
                    <a href="https://github.com/danspielman/Laplacians.jl">
                        
                            <i class="fa fa-github"></i>
                        
                        GitHub
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#erdosrenyi">ErdosRenyi</a></li>
        
    
        <li class="main "><a href="#erdosrenyicluster">ErdosRenyiCluster</a></li>
        
    
        <li class="main "><a href="#erdosrenyiclusterfix">ErdosRenyiClusterFix</a></li>
        
    
        <li class="main "><a href="#laplacians">Laplacians</a></li>
        
    
        <li class="main "><a href="#rootedtree">RootedTree</a></li>
        
    
        <li class="main "><a href="#augtreeprecon">augTreePrecon</a></li>
        
    
        <li class="main "><a href="#augtreesolver">augTreeSolver</a></li>
        
    
        <li class="main "><a href="#augmenttree">augmentTree</a></li>
        
    
        <li class="main "><a href="#backindices">backIndices</a></li>
        
    
        <li class="main "><a href="#biggestcomp">biggestComp</a></li>
        
    
        <li class="main "><a href="#cg">cg</a></li>
        
    
        <li class="main "><a href="#chimera">chimera</a></li>
        
    
        <li class="main "><a href="#compdepth">compDepth</a></li>
        
    
        <li class="main "><a href="#compstretches">compStretches</a></li>
        
    
        <li class="main "><a href="#completebinarytree">completeBinaryTree</a></li>
        
    
        <li class="main "><a href="#completegraph">completeGraph</a></li>
        
    
        <li class="main "><a href="#components">components</a></li>
        
    
        <li class="main "><a href="#deg">deg</a></li>
        
    
        <li class="main "><a href="#diagmat">diagmat</a></li>
        
    
        <li class="main "><a href="#edgevertexmat">edgeVertexMat</a></li>
        
    
        <li class="main "><a href="#findentries">findEntries</a></li>
        
    
        <li class="main "><a href="#floatgraph">floatGraph</a></li>
        
    
        <li class="main "><a href="#generalizednecklace">generalizedNecklace</a></li>
        
    
        <li class="main "><a href="#generalizedring">generalizedRing</a></li>
        
    
        <li class="main "><a href="#grid2">grid2</a></li>
        
    
        <li class="main "><a href="#grid2coords">grid2coords</a></li>
        
    
        <li class="main "><a href="#growngraph">grownGraph</a></li>
        
    
        <li class="main "><a href="#growngraphd">grownGraphD</a></li>
        
    
        <li class="main "><a href="#hypercube">hyperCube</a></li>
        
    
        <li class="main "><a href="#isconnected">isConnected</a></li>
        
    
        <li class="main "><a href="#joingraphs">joinGraphs</a></li>
        
    
        <li class="main "><a href="#kruskal">kruskal</a></li>
        
    
        <li class="main "><a href="#lap">lap</a></li>
        
    
        <li class="main "><a href="#lapchol">lapChol</a></li>
        
    
        <li class="main "><a href="#lapwrapsolver">lapWrapSolver</a></li>
        
    
        <li class="main "><a href="#mapweight">mapweight</a></li>
        
    
        <li class="main "><a href="#mattotree">matToTree</a></li>
        
    
        <li class="main "><a href="#mattotreedepth">matToTreeDepth</a></li>
        
    
        <li class="main "><a href="#maxflow">maxflow</a></li>
        
    
        <li class="main "><a href="#nbri">nbri</a></li>
        
    
        <li class="main "><a href="#nbrs">nbrs</a></li>
        
    
        <li class="main "><a href="#pathgraph">pathGraph</a></li>
        
    
        <li class="main "><a href="#pcg">pcg</a></li>
        
    
        <li class="main "><a href="#plotgraph">plotGraph</a></li>
        
    
        <li class="main "><a href="#prefattach">prefAttach</a></li>
        
    
        <li class="main "><a href="#prim">prim</a></li>
        
    
        <li class="main "><a href="#productgraph">productGraph</a></li>
        
    
        <li class="main "><a href="#purerandomgraph">pureRandomGraph</a></li>
        
    
        <li class="main "><a href="#randgenring">randGenRing</a></li>
        
    
        <li class="main "><a href="#randmatching">randMatching</a></li>
        
    
        <li class="main "><a href="#randregular">randRegular</a></li>
        
    
        <li class="main "><a href="#randweight">randWeight</a></li>
        
    
        <li class="main "><a href="#randishkruskal">randishKruskal</a></li>
        
    
        <li class="main "><a href="#randishprim">randishPrim</a></li>
        
    
        <li class="main "><a href="#randperm">randperm</a></li>
        
    
        <li class="main "><a href="#readij">readIJ</a></li>
        
    
        <li class="main "><a href="#readijv">readIJV</a></li>
        
    
        <li class="main "><a href="#ringgraph">ringGraph</a></li>
        
    
        <li class="main "><a href="#setvalue">setValue</a></li>
        
    
        <li class="main "><a href="#shortintgraph">shortIntGraph</a></li>
        
    
        <li class="main "><a href="#shortestpathtree">shortestPathTree</a></li>
        
    
        <li class="main "><a href="#shortestpaths">shortestPaths</a></li>
        
    
        <li class="main "><a href="#spectralcoords">spectralCoords</a></li>
        
    
        <li class="main "><a href="#spectraldrawing">spectralDrawing</a></li>
        
    
        <li class="main "><a href="#subsampleedges">subsampleEdges</a></li>
        
    
        <li class="main "><a href="#tarjanstretch">tarjanStretch</a></li>
        
    
        <li class="main "><a href="#tounitvector">toUnitVector</a></li>
        
    
        <li class="main "><a href="#twolift">twoLift</a></li>
        
    
        <li class="main "><a href="#uniformweight">uniformWeight</a></li>
        
    
        <li class="main "><a href="#uniformweight_1">uniformWeight!</a></li>
        
    
        <li class="main "><a href="#unweight">unweight</a></li>
        
    
        <li class="main "><a href="#vectocomps">vecToComps</a></li>
        
    
        <li class="main "><a href="#weighti">weighti</a></li>
        
    
        <li class="main "><a href="#writeijv">writeIJV</a></li>
        
    
        <li class="main "><a href="#wtedchimera">wtedChimera</a></li>
        
    
    </ul>
</div></div>
            <div class="col-md-9" role="main">

<h3 id="erdosrenyi">ErdosRenyi</h3>
<p>Generate a random graph on n vertices with m edges. The actual number of edges will probably be smaller, as we sample with replacement</p>
<pre><code class="julia">ErdosRenyi(n::Integer, m::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:280</p>
<h3 id="erdosrenyicluster">ErdosRenyiCluster</h3>
<p>Generate an ER graph with average degree k, and then return the largest component. Will probably have fewer than n vertices. If you want to add a tree to bring it back to n, try ErdosRenyiClusterFix.</p>
<pre><code class="julia">ErdosRenyiCluster(n::Integer, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:294</p>
<h3 id="erdosrenyiclusterfix">ErdosRenyiClusterFix</h3>
<p>Like an Erdos-Renyi cluster, but add back a tree so it has n vertices</p>
<pre><code class="julia">ErdosRenyiClusterFix(n::Integer, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:307</p>
<h3 id="laplacians">Laplacians</h3>
<p>A package for graph computations related to graph Laplacians</p>
<p>Graphs are represented by sparse adjacency matrices, etc.</p>
<h3 id="rootedtree">RootedTree</h3>
<p><strong>Summary:</strong></p>
<pre><code class="julia">type Laplacians.RootedTree{Tval,Tind} &lt;: Any
</code></pre>

<p><strong>Fields:</strong></p>
<pre><code class="julia">root     :: Tind
parent   :: Array{Tind,1}
children :: Array{Tind,1}
weights  :: Array{Tval,1}
numKids  :: Array{Tind,1}
kidsPtr  :: Array{Tind,1}
</code></pre>

<h3 id="augtreeprecon">augTreePrecon</h3>
<p>This is an augmented spanning tree preconditioner for diagonally dominant linear systems.  It takes as optional input a tree growing algorithm. The default is a randomized variant of Kruskal. It adds back 2sqrt(n) edges via augmentTree. With the right tree, it should never be too bad.</p>
<pre><code class="julia">augTreePrecon{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/solvers.jl:188</p>
<h3 id="augtreesolver">augTreeSolver</h3>
<p>This is the solver that calls augTreePrecon</p>
<pre><code class="julia">augTreeSolver{Tv,Ti}(ddmat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/solvers.jl:210</p>
<h3 id="augmenttree">augmentTree</h3>
<p>Takes as input a tree and an adjacency matrix of a graph. It then computes the stretch of every edge of the graph wrt the tree.  It then adds back the k edges of highest stretch, and k edges sampled according to stretch</p>
<pre><code class="julia">augmentTree{Tv,Ti}(tree::SparseMatrixCSC{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti}, k::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/solvers.jl:138</p>
<h3 id="backindices">backIndices</h3>
<p>computes the back indices in a graph in O(M+N). works if for every edge (u,v), (v,u) is also in the graph </p>
<pre><code class="julia">backIndices{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:22</p>
<h3 id="biggestcomp">biggestComp</h3>
<p>Return the biggest component in a graph, as a graph</p>
<pre><code class="julia">biggestComp(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:154</p>
<h3 id="cg">cg</h3>
<pre><code class="julia">cg(mat, b::Array{Float64,1})
cg(mat, b::Array{Float32,1})
cg(mat, b)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/pcg.jl:29</p>
<h3 id="chimera">chimera</h3>
<p>Builds the kth chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.</p>
<p>Builds a chimeric graph on n vertices. The components come from pureRandomGraph, connected by joinGraphs, productGraph and generalizedNecklace</p>
<pre><code class="julia">chimera(n::Integer)
chimera(n::Integer, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:378</p>
<h3 id="compdepth">compDepth</h3>
<pre><code class="julia">compDepth{Tv,Ti}(t::Laplacians.RootedTree{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/treeAlgs.jl:249</p>
<h3 id="compstretches">compStretches</h3>
<pre><code class="julia">compStretches{Tv,Ti}(t::Laplacians.RootedTree{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti})
compStretches{Tv,Ti}(tree::SparseMatrixCSC{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/treeAlgs.jl:319</p>
<h3 id="completebinarytree">completeBinaryTree</h3>
<p>The complete binary tree on n vertices</p>
<pre><code class="julia">completeBinaryTree(n::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:82</p>
<h3 id="completegraph">completeGraph</h3>
<p>The complete graph</p>
<pre><code class="julia">completeGraph(n::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:17</p>
<h3 id="components">components</h3>
<p>Computes the connected components of a graph. Returns them as a vector of length equal to the number of vertices. The vector numbers the components from 1 through the maximum number. For example,</p>
<pre><code class="julia">gr = ErdosRenyi(10,11)
c = components(gr)

10-element Array{Int64,1}:
 1
 1
 1
 1
 2
 1
 1
 1
 3
 2
</code></pre>

<pre><code class="julia">components{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:65</p>
<h3 id="deg">deg</h3>
<pre><code class="julia">deg{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:11</p>
<h3 id="diagmat">diagmat</h3>
<p>returns the diagonal matrix(as a sparse matrix) of a graph</p>
<pre><code class="julia">diagmat{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:194</p>
<h3 id="edgevertexmat">edgeVertexMat</h3>
<p>The signed edge-vertex adjacency matrix</p>
<pre><code class="julia">edgeVertexMat(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:56</p>
<h3 id="findentries">findEntries</h3>
<p>similar to findnz, but also returns 0 entries that have an edge in the sparse matrix </p>
<pre><code class="julia">findEntries{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:60</p>
<h3 id="floatgraph">floatGraph</h3>
<p>Convert the nonzero entries in a graph to Float64</p>
<pre><code class="julia">floatGraph(a::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:6</p>
<h3 id="generalizednecklace">generalizedNecklace</h3>
<p>Constructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.</p>
<pre><code class="julia">generalizedNecklace{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, H::SparseMatrixCSC{Tv,Ti&lt;:Integer}, k::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:214</p>
<h3 id="generalizedring">generalizedRing</h3>
<p>A generalization of a ring graph. The vertices are integers modulo n. Two are connected if their difference is in gens. For example, </p>
<pre><code>generalizedRing(17, [1 5])
</code></pre>

<pre><code class="julia">generalizedRing(n::Int64, gens)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:38</p>
<h3 id="grid2">grid2</h3>
<p>An n-by-m grid graph.  iostropy is the weighting on edges in one direction.</p>
<pre><code class="julia">grid2(n::Int64)
grid2(n::Int64, m::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:102</p>
<h3 id="grid2coords">grid2coords</h3>
<p>Coordinates for plotting the vertices of the n-by-m grid graph</p>
<pre><code class="julia">grid2coords(n::Int64, m::Int64)
grid2coords(n)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:106</p>
<h3 id="growngraph">grownGraph</h3>
<p>Create a graph on n vertices. For each vertex, give it k edges to randomly chosen prior vertices. This is a variety of a preferential attachment graph.    </p>
<pre><code class="julia">grownGraph(n::Int64, k::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:145</p>
<h3 id="growngraphd">grownGraphD</h3>
<p>Like a grownGraph, but it forces the edges to all be distinct. It starts out with a k+1 clique on the first k vertices</p>
<pre><code class="julia">grownGraphD(n::Int64, k::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:177</p>
<h3 id="hypercube">hyperCube</h3>
<p>The d dimensional hypercube.  Has 2^d vertices</p>
<pre><code class="julia">hyperCube(d::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:68</p>
<h3 id="isconnected">isConnected</h3>
<p>Returns true if graph is connected.  Calls components.</p>
<pre><code class="julia">isConnected(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:112</p>
<h3 id="joingraphs">joinGraphs</h3>
<p>create a disjoint union of graphs a and b,  and then put k random edges between them</p>
<pre><code class="julia">joinGraphs{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind}, b::SparseMatrixCSC{Tval,Tind}, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:100</p>
<h3 id="kruskal">kruskal</h3>
<p>Uses Kruskal's algorithm to compute a minimum (or maximum) spanning tree. Set kind=:max if you want the max spanning tree. It returns it a a graph</p>
<pre><code class="julia">kruskal{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:391</p>
<h3 id="lap">lap</h3>
<p>Create a Laplacian matrix from an adjacency matrix. We might want to do this differently, say by enforcing symmetry</p>
<pre><code class="julia">lap(a)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:12</p>
<h3 id="lapchol">lapChol</h3>
<h3 id="lapwrapsolver">lapWrapSolver</h3>
<p>Takes a solver for solving nonsingular sdd systems, and returns a solver for solving Laplacian systems. The optional args tol and maxits are not necessarily taken by all solvers.  But, if they are, one can pass them here</p>
<pre><code class="julia">lapWrapSolver(solver)
lapWrapSolver(solver, la::AbstractArray{T,N})
lapWrapSolver(solver, la::AbstractArray{T,N}, b)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/solvers.jl:108</p>
<h3 id="mapweight">mapweight</h3>
<p>Create a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write</p>
<pre><code class="julia">b = mapweight(a, x-&gt;rand(1)[1])
</code></pre>

<pre><code class="julia">mapweight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind}, f)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:29</p>
<h3 id="mattotree">matToTree</h3>
<pre><code class="julia">matToTree{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
matToTree{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, root::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/treeAlgs.jl:32</p>
<h3 id="mattotreedepth">matToTreeDepth</h3>
<pre><code class="julia">matToTreeDepth{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
matToTreeDepth{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, root::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/treeAlgs.jl:98</p>
<h3 id="maxflow">maxflow</h3>
<p>implementation of Dinic's algorithm. computes the maximum flow and min-cut in G between s and t. we consider the adjacency matrix to be the capacity matrix </p>
<pre><code class="julia">maxflow{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti}, s::Int64, t::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/flow.jl:4</p>
<h3 id="nbri">nbri</h3>
<pre><code class="julia">nbri{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti, i::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:12</p>
<h3 id="nbrs">nbrs</h3>
<pre><code class="julia">nbrs{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:14</p>
<h3 id="pathgraph">pathGraph</h3>
<p>The path graph on n vertices</p>
<pre><code class="julia">pathGraph(n::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:8</p>
<h3 id="pcg">pcg</h3>
<pre><code class="julia">pcg(mat, b::Array{Float64,1}, pre)
pcg(mat, b::Array{Float32,1}, pre)
pcg(mat, b, pre)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/pcg.jl:42</p>
<h3 id="plotgraph">plotGraph</h3>
<p>Plots graph gr with coordinates (x,y)</p>
<pre><code class="julia">plotGraph(gr, x, y)
plotGraph(gr, x, y, color)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:118</p>
<h3 id="prefattach">prefAttach</h3>
<p>A preferential attachment graph in which each vertex has k edges to those that come before.  These are chosen with probability p to be from a random vertex, and with probability 1-p to come from the endpoint of a random edge. It begins with a k-clique on the first k+1 vertices.</p>
<pre><code class="julia">prefAttach(n::Int64, k::Int64, p::Float64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:201</p>
<h3 id="prim">prim</h3>
<pre><code class="julia">prim(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:422</p>
<h3 id="productgraph">productGraph</h3>
<p>The Cartesian product of two graphs.  When applied to two paths, it gives a grid.</p>
<pre><code class="julia">productGraph(a0::SparseMatrixCSC{Tv,Ti&lt;:Integer}, a1::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:47</p>
<h3 id="purerandomgraph">pureRandomGraph</h3>
<p>Generate a random graph with n vertices from one of our natural distributions</p>
<pre><code class="julia">pureRandomGraph(n::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:322</p>
<h3 id="randgenring">randGenRing</h3>
<p>A random generalized ring graph of degree k. Gens always contains 1, and the other k-1 edge types are chosen from an exponential distribution</p>
<pre><code class="julia">randGenRing(n::Int64, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:61</p>
<h3 id="randmatching">randMatching</h3>
<p>A random matching on n vertices</p>
<pre><code class="julia">randMatching(n::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:117</p>
<h3 id="randregular">randRegular</h3>
<p>A sum of k random matchings on n vertices</p>
<pre><code class="julia">randRegular(n::Int64, k::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:130</p>
<h3 id="randweight">randWeight</h3>
<p>Applies one of a number of random weighting schemes to the edges of the graph</p>
<pre><code class="julia">randWeight(a)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:449</p>
<h3 id="randishkruskal">randishKruskal</h3>
<pre><code class="julia">randishKruskal{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/randTrees.jl:10</p>
<h3 id="randishprim">randishPrim</h3>
<pre><code class="julia">randishPrim{Tval,Tind}(mat::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/randTrees.jl:47</p>
<h3 id="randperm">randperm</h3>
<pre><code class="rst">..  randperm([rng,] n)

Construct a random permutation of length ``n``. The optional ``rng`` argument
specifies a random number generator, see :ref:`Random Numbers &lt;random-numbers&gt;`.
</code></pre>

<p>Randomly permutes the vertex indices</p>
<pre><code class="julia">randperm(r::AbstractRNG, n::Integer)
randperm(n::Integer)
randperm(mat::AbstractArray{T,2})
randperm(f::Expr)
</code></pre>

<p>at random.jl:1341</p>
<h3 id="readij">readIJ</h3>
<p>to read a simple edge list, each line being an (i, j) pair</p>
<pre><code class="julia">readIJ(filename::AbstractString)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/IO.jl:4</p>
<h3 id="readijv">readIJV</h3>
<p>to read a simple edge list, each line being an (i, j, v) pair. The parens should not be there in the format, just commas separating. To generate this format in Matlab, you just need to be careful to write the vertex indices with sufficient precision.  For example, you can do this</p>
<pre><code>&gt;&gt; [ai,aj,av] = find(triu(a));
&gt;&gt; dlmwrite('graph.txt',[ai,aj,av],'precision',9);
</code></pre>

<pre><code class="julia">readIJV(filename::AbstractString)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/IO.jl:25</p>
<h3 id="ringgraph">ringGraph</h3>
<p>The simple ring on n vertices</p>
<pre><code class="julia">ringGraph(n::Int64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:23</p>
<h3 id="setvalue">setValue</h3>
<pre><code class="julia">setValue{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti, i::Ti, a::Tv)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:17</p>
<h3 id="shortintgraph">shortIntGraph</h3>
<p>Convert the indices in a graph to 32-bit ints.  This takes less storage, but does not speed up much</p>
<pre><code class="julia">shortIntGraph(a::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:3</p>
<h3 id="shortestpathtree">shortestPathTree</h3>
<p>Computes the shortest path tree, and returns it as a sparse matrix. Treats edge weights as reciprocals of lengths. For example:</p>
<pre><code class="julia">a = [0 2 1; 2 0 3; 1 3 0]
tr = full(shortestPathTree(sparse(a),1))

3x3 Array{Float64,2}:
 0.0  2.0  0.0
 2.0  0.0  3.0
 0.0  3.0  0.0
</code></pre>

<pre><code class="julia">shortestPathTree(a, start)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:223</p>
<h3 id="shortestpaths">shortestPaths</h3>
<p>Computes the lenghts of shortest paths from <code>start</code>. Returns both a vector of the lenghts, and the parent array in the shortest path tree.</p>
<p>This algorithm treats edge weights as reciprocals of distances. DOC BETTER</p>
<pre><code class="julia">shortestPaths{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, start::Ti)
shortestPaths{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:170</p>
<h3 id="spectralcoords">spectralCoords</h3>
<p>Computes the spectral coordinates of a graph</p>
<pre><code class="julia">spectralCoords(a)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:163</p>
<h3 id="spectraldrawing">spectralDrawing</h3>
<p>Computes spectral coordinates, and then uses plotGraph to draw</p>
<pre><code class="julia">spectralDrawing(a)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:155</p>
<h3 id="subsampleedges">subsampleEdges</h3>
<p>Create a new graph from the old, but keeping edge edge with probability <code>p</code></p>
<pre><code class="julia">subsampleEdges(a::SparseMatrixCSC{Float64,Int64}, p::Float64)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:65</p>
<h3 id="tarjanstretch">tarjanStretch</h3>
<pre><code class="julia">tarjanStretch{Tv,Ti}(t::Laplacians.RootedTree{Tv,Ti}, mat::SparseMatrixCSC{Tv,Ti}, depth::Array{Tv,1})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/treeAlgs.jl:272</p>
<h3 id="tounitvector">toUnitVector</h3>
<p>creates a unit vector of length n from a given set of integers, with weights based on the number of occurences</p>
<pre><code class="julia">toUnitVector(a::Array{Int64,1}, n)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:172</p>
<h3 id="twolift">twoLift</h3>
<p>Creats a 2-lift of a.  <code>flip</code> is a boolean indicating which edges cross</p>
<pre><code class="julia">twoLift(a)
twoLift(a, flip::AbstractArray{Bool,1})
twoLift(a, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:88</p>
<h3 id="uniformweight">uniformWeight</h3>
<p>Put a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.</p>
<pre><code class="julia">uniformWeight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:38</p>
<h3 id="uniformweight_1">uniformWeight!</h3>
<p>Set the weight of every edge to 1</p>
<pre><code class="julia">uniformWeight!(mat::SparseMatrixCSC{Tv,Ti&lt;:Integer})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:42</p>
<h3 id="unweight">unweight</h3>
<p>Create a new graph in that is the same as the original, but with all edge weights 1</p>
<pre><code class="julia">unweight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphOps.jl:16</p>
<h3 id="vectocomps">vecToComps</h3>
<p>This turns a component vector, like that generated by components, into an array of arrays of indices of vertices in each component.  For example,</p>
<pre><code class="julia">comps = vecToComps(c)

3-element Array{Array{Int64,1},1}:
 [1,2,3,4,6,7,8]
 [5,10]         
 [9]   
</code></pre>

<pre><code class="julia">vecToComps{Ti}(compvec::Array{Ti,1})
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphAlgs.jl:131</p>
<h3 id="weighti">weighti</h3>
<pre><code class="julia">weighti{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, v::Ti, i::Ti)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphUtils.jl:13</p>
<h3 id="writeijv">writeIJV</h3>
<p>Writes the upper portion of a matrix in ijv format, one row for each edge, separated by commas.  Only writes the upper triangular portion. The result can be read from Matlab like this:</p>
<pre><code>&gt;&gt; dl = dlmread('graph.txt');
&gt;&gt; a = sparse(dl(:,1),dl(:,2),dl(:,3));
&gt;&gt; n = max(size(a))
&gt;&gt; a(n,n) = 0;
&gt;&gt; a = a + a';
</code></pre>

<pre><code class="julia">writeIJV(filename::AbstractString, mat)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/IO.jl:52</p>
<h3 id="wtedchimera">wtedChimera</h3>
<p>Builds the kth wted chimeric graph on n vertices. It does this by resetting the random number generator seed. It should captute the state of the generator before that and then return it, but it does not yet.</p>
<p>Generate a chimera, and then apply a random weighting scheme</p>
<pre><code class="julia">wtedChimera(n::Integer)
wtedChimera(n::Integer, k::Integer)
</code></pre>

<p>at /Users/spielman/git/Laplacians.jl/src/graphGenerators.jl:514</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            
            <center>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</center>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script src="../js/base.js"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
        <script src="../mathjaxhelper.js"></script>
    </body>
</html>