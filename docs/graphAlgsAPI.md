# graphAlgs
### components
Computes the connected components of a graph. Returns them as a vector of length equal to the number of vertices. The vector numbers the components from 1 through the maximum number. For example,

```julia
gr = ErdosRenyi(10,11)
c = components(gr)

10-element Array{Int64,1}:
 1
 1
 1
 1
 2
 1
 1
 1
 3
 2
```


```julia
components{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
```

graphAlgs.jl:65



### isConnected
Returns true if graph is connected.  Calls components.


```julia
isConnected(mat::SparseMatrixCSC{Tv,Ti<:Integer})
```

graphAlgs.jl:113



### vecToComps
This turns a component vector, like that generated by components, into an array of arrays of indices of vertices in each component.  For example,

```julia
comps = vecToComps(c)

3-element Array{Array{Int64,1},1}:
 [1,2,3,4,6,7,8]
 [5,10]
 [9]
```


```julia
vecToComps{Ti}(compvec::Array{Ti,1})
```

graphAlgs.jl:136



### biggestComp
Return the biggest component in a graph, as a graph


```julia
biggestComp(mat::SparseMatrixCSC{Tv,Ti<:Integer})
```

graphAlgs.jl:159



### shortestPaths
Computes the lenghts of shortest paths from `start`. Returns both a vector of the lenghts, and the parent array in the shortest path tree.

This algorithm treats edge weights as reciprocals of distances. DOC BETTER


```julia
shortestPaths{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti}, start::Ti)
shortestPaths{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
```

graphAlgs.jl:175



### shortestPathTree
Computes the shortest path tree, and returns it as a sparse matrix. Treats edge weights as reciprocals of lengths. For example:

```julia
a = [0 2 1; 2 0 3; 1 3 0]
tr = full(shortestPathTree(sparse(a),1))

3x3 Array{Float64,2}:
 0.0  2.0  0.0
 2.0  0.0  3.0
 0.0  3.0  0.0
```


```julia
shortestPathTree(a, start)
```

graphAlgs.jl:239



### kruskal
Uses Kruskal's algorithm to compute a minimum (or maximum) spanning tree. Set kind=:max if you want the max spanning tree. It returns it a a graph


```julia
kruskal{Tv,Ti}(mat::SparseMatrixCSC{Tv,Ti})
```

graphAlgs.jl:407



### prim
`prim(mat::SparseMatrixCSC; rev=false)` Compute a minimum spanning tree of the matrix `mat`.   If rev is true, computes a maximum spanning tree.


```julia
prim(mat::SparseMatrixCSC{Tv,Ti<:Integer})
```

graphAlgs.jl:440



