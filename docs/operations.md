<!-- AUTOGENERATED. See 'doc/build.jl' for source. -->

## Operations on one graph
### shortIntGraph
```
shortIntGraph(a::SparseMatrixCSC{Tv,Ti<:Integer})
```
Convert the indices in a graph to 32-bit ints.  This takes less storage, but does not speed up much

### lap
```
lap(a)
```
Create a Laplacian matrix from an adjacency matrix.

We might want to do this differently, say by enforcing symmetry

### unweight
```
unweight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind})
```
Create a new graph in that is the same as the original, but with all edge weights 1

### mapweight
```
mapweight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind}, f)
```
Create a new graph that is the same as the original, but with f applied to each nonzero entry of a. For example, to make the weight of every edge uniform in [0,1], we could write

```julia
b = mapweight(a, x->rand(1)[1])
```

### uniformWeight
```
uniformWeight{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind})
```
Put a uniform [0,1] weight on every edge.  This is an example of how to use mapweight.

### edgeVertexMat
```
edgeVertexMat(mat::SparseMatrixCSC{Tv,Ti<:Integer})
```
The signed edge-vertex adjacency matrix

### subsampleEdges
```
subsampleEdges(a::SparseMatrixCSC{Float64,Int64}, p::Float64)
```
Create a new graph from the old, but keeping edge edge with probability `p`

### twoLift
```
twoLift(a)
twoLift(a, flip::AbstractArray{Bool,1})
twoLift(a, k::Integer)
```
Creats a 2-lift of a.  `flip` is a boolean indicating which edges cross

### plotGraph
```
plotGraph(gr, x, y)
plotGraph(gr, x, y, color)
```
Plots graph gr with coordinates (x,y)

### spectralDrawing
```
spectralDrawing(a)
```
Computes spectral coordinates, and then uses plotGraph to draw

### spectralCoords
```
spectralCoords(a)
```
Computes the spectral coordinates of a graph

### diagmat
```
diagmat{Tv,Ti}(G::SparseMatrixCSC{Tv,Ti})
```
returns the diagonal matrix(as a sparse matrix) of a graph

## Operations on two graphs### joinGraphs
```
joinGraphs{Tval,Tind}(a::SparseMatrixCSC{Tval,Tind}, b::SparseMatrixCSC{Tval,Tind}, k::Integer)
```
create a disjoint union of graphs a and b,  and then put k random edges between them

### generalizedNecklace
```
generalizedNecklace{Tv,Ti}(A::SparseMatrixCSC{Tv,Ti}, H::SparseMatrixCSC{Tv,Ti<:Integer}, k::Int64)
```
Constructs a generalized necklace graph starting with two graphs A and H. The resulting new graph will be constructed by expanding each vertex in H to an instance of A. k random edges will be generated between components. Thus, the resulting graph may have weighted edges.

